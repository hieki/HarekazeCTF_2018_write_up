
# HarekazeCTF 2018 write-up

HarekazeCTF 2018 https://ctf.harekaze.com/ に参加した。

知り合い2人とチームAneMoneを結成して雰囲気でやっていった。

結果としては、スコア457pt、76位だった。

全員初心者という事で、結果的にスコアを稼げたのは自分だけで、もうちょっと難易度を考慮して作業分担するべきだったなーという反省点がある。

個人的には浅いCTF歴のわりには頑張れたのではないかという気がしているが、どうなんでしょうね、何もわからん。

# Obfuscated Password Checker

ブラウザ開いてminifyされたJSをパースして、ブレークポイントを起きまくってボタンを押した後の挙動を調査してみたら、入力値を比較している箇所を見つけて無事にフラグゲット。

力技であった。

難読化JSを解析する合理的な手法があったら知りたい……。

# Unnormalized-form Data

とりあえず手元にPostgreSQLとpgAdmin3を突っ込んでSQLを流し、Functionを実行してみる。

`HarekazeCTF{}` という文字列が返ってきて、どこかで想定すべきデータが欠落している模様。

FunctionのSQLを整形したものがこれ。

```
WITH RECURSIVE r(i, j, a) AS
(
    VALUES (0,1,'{a,B,4}'::TEXT[]), (0,2,'{d,B,7}'), (0,3,'{b,F,1}'), (0,4,'{b,D,7}'), (0,5,'{b,E,7}'),
  (0,6,'{a,E,3}'), (0,7,'{b,A,2}'), (0,8,'{d,F,2}'), (0,9,'{d,F,7}'), (0,10,'{a,A,4}'),
  (0,11,'{b,H,7}'), (0,12,'{b,H,5}'), (0,13,'{a,E,6}'), (0,14,'{d,C,3}'), (0,15,'{d,E,5}'),
  (0,16,'{d,B,1}'), (0,17,'{c,A,5}'), (0,18,'{b,G,6}'), (0,19,'{d,E,7}'), (0,20,'{c,F,7}'),
  (0,21,'{c,B,2}'), (0,22,'{d,D,3}'), (0,23,'{c,A,1}'), (0,24,'{a,G,1}'), (0,25,'{c,G,7}'),
  (0,26,'{a,B,3}'), (0,27,'{a,C,5}'), (0,28,'{a,C,3}'), (0,29,'{d,C,6}')
  UNION
    SELECT i + 1, j, d
      FROM r, rel
     WHERE i < 40 AND a::TEXT[] <@ s
 )
  SELECT string_agg(c, '')
    FROM (
            SELECT c
              FROM r, dic
             WHERE i = 40
               AND r.a::TEXT[] @> dic.a
             ORDER BY j
          ) AS t;
```

VALUESが怪しいですね。

dicテーブルにVALUESのレコードを探しに行くと、前から順にHarekaze...と続いている様子。たぶんこれでしょう。


SQLを書きましょう。

```
SELECT * FROM dic
WHERE a =
'{a,B,4}' OR a =
'{d,B,7}' OR a =
'{b,F,1}' OR a =
'{b,D,7}' OR a =
'{b,E,7}' OR a =
'{a,E,3}' OR a =
'{b,A,2}' OR a =
'{d,F,2}' OR a =
'{d,F,7}' OR a =
'{a,A,4}' OR a =
'{b,H,7}' OR a =
'{b,H,5}' OR a =
'{a,E,6}' OR a =
'{d,C,3}' OR a =
'{d,E,5}' OR a =
'{d,B,1}' OR a =
'{c,A,5}' OR a =
'{b,G,6}' OR a =
'{d,E,7}' OR a =
'{c,F,7}' OR a =
'{c,B,2}' OR a =
'{d,D,3}' OR a =
'{c,A,1}' OR a =
'{a,G,1}' OR a =
'{c,G,7}' OR a =
'{a,B,3}' OR a =
'{a,C,5}' OR a =
'{a,C,3}' OR a =
'{d,C,6}'
```

乱雑さここに極まれりといった風体のクエリですが、次のような結果になる。

```
"{d,B,7}";"H"
"{c,A,1}";"r"
"{c,B,2}";"_"
"{a,G,1}";"p"
"{d,E,7}";"e"
"{b,G,6}";"e"
"{d,B,1}";"r"
"{a,C,5}";"n"
"{d,F,2}";"z"
"{b,E,7}";"e"
"{b,H,5}";"F"
"{a,C,3}";"s"
"{d,D,3}";"0"
"{b,D,7}";"r"
"{b,F,1}";"a"
"{a,E,3}";"k"
"{a,E,6}";"T"
"{c,G,7}";"h"
"{d,F,7}";"e"
"{a,A,4}";"C"
"{b,A,2}";"a"
"{c,F,7}";"n"
"{b,H,7}";"T"
"{d,C,3}";"h"
"{d,E,5}";"1"
"{c,A,5}";"t"
```

当然ながら順序がメチャクチャなので適当にマッピングさせて、ガッとやる。

```
const obj = {"{d,B,7}":"H",
"{c,A,1}":"r",
"{c,B,2}":"_",
"{a,G,1}":"p",
"{d,E,7}":"e",
"{b,G,6}":"e",
"{d,B,1}":"r",
"{a,C,5}":"n",
"{d,F,2}":"z",
"{b,E,7}":"e",
"{b,H,5}":"F",
"{a,C,3}":"s",
"{d,D,3}":"0",
"{b,D,7}":"r",
"{b,F,1}":"a",
"{a,E,3}":"k",
"{a,E,6}":"T",
"{c,G,7}":"h",
"{d,F,7}":"e",
"{a,A,4}":"C",
"{b,A,2}":"a",
"{c,F,7}":"n",
"{b,H,7}":"T",
"{d,C,3}":"h",
"{d,E,5}":"1",
"{c,A,5}":"t"}

const res = ['{a,B,4}',
'{d,B,7}',
'{b,F,1}',
'{b,D,7}',
'{b,E,7}',
'{a,E,3}',
'{b,A,2}',
'{d,F,2}',
'{d,F,7}',
'{a,A,4}',
'{b,H,7}',
'{b,H,5}',
'{a,E,6}',
'{d,C,3}',
'{d,E,5}',
'{d,B,1}',
'{c,A,5}',
'{b,G,6}',
'{d,E,7}',
'{c,F,7}',
'{c,B,2}',
'{d,D,3}',
'{c,A,1}',
'{a,G,1}',
'{c,G,7}',
'{a,B,3}',
'{a,C,5}',
'{a,C,3}',
'{d,C,6}'].map((i) => { return obj[i]})

// => [undefined,"H","a","r","e","k","a","z","e","C","T","F","T","h","1","r","t","e","e","n","_","0","r","p","h",undefined,"n","s",undefined]

res.join("")
// => "HarekazeCTFTh1rteen_0rphns"
```

力技にも程がある。

なんかundefinedが混じってるし中括弧も見当たらなくて不安になってきたので、クエリを書き換えて調査する。

```
WITH RECURSIVE r(i, j, a) AS
(
    VALUES (0,1,'{a,B,4}'::TEXT[]), (0,2,'{d,B,7}'), (0,3,'{b,F,1}'), (0,4,'{b,D,7}'), (0,5,'{b,E,7}'),
  (0,6,'{a,E,3}'), (0,7,'{b,A,2}'), (0,8,'{d,F,2}'), (0,9,'{d,F,7}'), (0,10,'{a,A,4}'),
  (0,11,'{b,H,7}'), (0,12,'{b,H,5}'), (0,13,'{a,E,6}'), (0,14,'{d,C,3}'), (0,15,'{d,E,5}'),
  (0,16,'{d,B,1}'), (0,17,'{c,A,5}'), (0,18,'{b,G,6}'), (0,19,'{d,E,7}'), (0,20,'{c,F,7}'),
  (0,21,'{c,B,2}'), (0,22,'{d,D,3}'), (0,23,'{c,A,1}'), (0,24,'{a,G,1}'), (0,25,'{c,G,7}'),
  (0,26,'{a,B,3}'), (0,27,'{a,C,5}'), (0,28,'{a,C,3}'), (0,29,'{d,C,6}')
  UNION
    SELECT i + 1, j, d
      FROM r, rel
     WHERE i < 40 AND a::TEXT[] <@ s
 )
  SELECT *
    FROM (
            SELECT *
              FROM r, dic
             WHERE i = 40
               AND r.a::TEXT[] @> dic.a
             ORDER BY j
          ) AS t;
```

```
40;1;"{d,B,7}";"{d,B,7}";"H"
40;2;"{b,F,1}";"{b,F,1}";"a"
40;3;"{b,D,7}";"{b,D,7}";"r"
40;4;"{b,E,7}";"{b,E,7}";"e"
40;5;"{a,E,3}";"{a,E,3}";"k"
40;6;"{b,A,2}";"{b,A,2}";"a"
40;7;"{d,F,2}";"{d,F,2}";"z"
40;8;"{d,F,7}";"{d,F,7}";"e"
40;9;"{a,A,4}";"{a,A,4}";"C"
40;10;"{b,H,7}";"{b,H,7}";"T"
40;11;"{b,H,5}";"{b,H,5}";"F"
40;12;"{d,C,6}";"{d,6,C}";"{"
40;29;"{a,B,4}";"{4,B,a}";"}"
```

二列目の末尾が29なのでフラグの文字数は29と推測する。

先程のフラグっぽい文字列に中括弧を補完して `HarekazeCTF{Th1rteen_0rphns}` 、28文字ですね。undefinedが悪さをしてそう。

フラグが有意な文字列っぽいのでThirteen_Orphnsでググったら『Thirteen Orphans』(ジェーン・リンドスコールド)がヒットしてコレやということでaを補完してフラグゲット。

# 15 puzzle

exeが渡されるので素直に開くと15パズルを1000回解けとのこと。

おもむろにdnSpyに食わせてC#のコードにデコンパイルする。

dnSpyの操作方法がわからなくて、ウォッチ式のウィンドウが画面下部に最小化されてることに気付かず、ブレークポイント貼れるのに変数の状態を見れないの意味不明過ぎる……と1時間くらい時間を無駄にした。

dnSpyは本当に凄くて、デコンパイルしたコードを書き換えてそのままコンパイルしてデバッグ実行するなどが出来る。

素朴に `if(this.score == 1000)` を `if(this.score == 0)` にして実行してみると、文字化けしたフラグが吐き出される。

パズルが解けたか否かの判定をしている部分を必ずtrueを返すようにして、1000回ボタンを押してみてもやはり文字化けする。


次に、FlagGeneratorを見るとbyte配列でflagが宣言されてて、これを素直にエンコーディングすると文字化けした何かが出て来る。

ウーームとなっていた所、よくよくコードを見てみるとフラグを表示する直前にflagのbyteを乱数で乗算演算しているのを見つけ、乱数でフラグを出力するって何……と2時間位悩む。


ここで乱数生成器が生成されてゆく様子を見てみましょう。

```
this.rand = new Random((from x in typeof(Form1).GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic)
			      select CRC32.Compute(x.GetMethodBody().GetILAsByteArray())).Aggregate((int x, int y) => x ^ y))
```

なんですかこれは……となり、コードをガチャガチャいじりながらデバッグしてると、コードを変更する度に `new Random()` に渡されるシード値が変動している事に気付く。しまった、これは罠だ！

慌てて初期状態のexeをもう一度dnSpyに食わせて、本来生成されるべきシード値を手に入れて、シード値を渡すようにコードを書き直し、勝利を確信しながら1プレイだけでフラグを吐き出すように書き直すと、またもフラグが文字化けしている。

冷静に乱数が生成される箇所をチェックしていると、どうやらパズルが解ける度に乱数生成して盤面を生成している様子。つまり、本来1000回乱数を生成して盤面を作り直した後に、更に乱数を生成してフラグを生成しているわけですね。

ということで `if(this.score == 0)` でアプローチするのではなく、パズルが解けたかの判定を常にtrueにして、1000回ボタンを押すとメッセージウィンドウにフラグが表示されます。

なるほど。


dnSpyが無かったら立ち向かえなかったことでしょう、ありがとうdnSpy、もっと日本人に知られてくれ。
